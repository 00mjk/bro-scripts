Index: src/bro.bif
===================================================================
--- src/bro.bif	(revision 6337)
+++ src/bro.bif	(working copy)
@@ -1657,6 +1657,64 @@
 	return new StringVal(md5_digest_print(digest));
 	%}
 
+%%{
+static map<BroString, md5_state_s> md5_states;
+%%}
+
+function md5_hash_init%(index: any%): bool
+	%{
+	ODesc d;
+	index->Describe(&d);
+	BroString *s = new BroString(1, d.TakeBytes(), d.Len());
+	if( md5_states.count(*s) < 1 )
+		{
+		md5_state_s h;
+		md5_init(&h);
+		md5_states[*s] = h;
+		delete s;
+		return new Val(1, TYPE_COUNT);
+		}
+	delete s;
+	return new Val(0, TYPE_COUNT);
+	%}
+	
+function md5_hash_update%(index: any, data: string%):bool
+	%{
+	ODesc d;
+	index->Describe(&d);
+	BroString *s = new BroString(1, d.TakeBytes(), d.Len());
+			
+	if( md5_states.count(*s) > 0 )
+		{
+		md5_append(&md5_states[*s], data->Bytes(), data->Len());
+		}
+	else
+		{
+		delete s;
+		return new Val(0, TYPE_BOOL);
+		}
+	delete s;
+	return new Val(1, TYPE_BOOL);
+	%}
+	
+function md5_hash_finish%(index: any%): string
+	%{
+	unsigned char digest[16];
+	ODesc d;
+	index->Describe(&d);		
+	BroString *s = new BroString(1, d.TakeBytes(), d.Len());
+	
+	if( md5_states.count(*s) > 0 )
+		{
+		md5_finish(&md5_states[*s], digest);
+		delete s;
+		md5_states.erase(*s);
+		return new StringVal(md5_digest_print(digest));
+		}
+	delete s;
+	return new StringVal("");
+	%}
+
 # Wrappings for rand() and srand()
 function rand%(max: count%): count
 	%{
